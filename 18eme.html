import hashlib
import hmac
import time
import random
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, List
import secrets

class CrashGameSimulator:
    """
    Educational simulation of a provably fair crash game.
    
    This demonstrates:
    - How provably fair algorithms work
    - Why crash points are truly random
    - Why prediction is mathematically impossible
    - The house edge mechanism
    """
    
    def __init__(self, server_seed: str = None, client_seed: str = None, house_edge: float = 0.01):
        """
        Initialize the crash game with provably fair seeding.
        
        In real crash games:
        - Server seed: Generated by the casino, kept secret initially
        - Client seed: Provided by the player, can be changed
        - Nonce: Increments with each round
        
        Args:
            server_seed: If None, cryptographically secure random seed is generated
            client_seed: If None, cryptographically secure random seed is generated
            house_edge: The mathematical advantage for the house (1% default)
        """
        self.server_seed = server_seed or secrets.token_hex(32)
        self.client_seed = client_seed or secrets.token_hex(32)
        self.nonce = 0
        self.house_edge = house_edge
        self.crash_history = []
        
        print(f"üîê Provably Fair Seeding")
        print(f"Server Seed (hash): {hashlib.sha256(self.server_seed.encode()).hexdigest()}")
        print(f"Client Seed: {self.client_seed}")
        print(f"House Edge: {house_edge*100}%\n")
    
    def generate_crash_point(self) -> float:
        """
        Generate a crash point using provably fair algorithm.
        
        The mathematics behind crash games:
        1. Generate a random integer from HMAC_SHA512(server_seed, client_seed + nonce)
        2. Convert to a float between 0 and 1
        3. Apply distribution: floor = 0.01 / (1 - random_float)
        4. Apply house edge: max(1, floor * (1 - house_edge))
        
        This creates a distribution where:
        - Lower multipliers are more common
        - Higher multipliers are exponentially rarer
        - The house maintains a mathematical edge
        - Results are verifiable by the player
        """
        self.nonce += 1
        
        # Step 1: Generate HMAC for provably fair random number
        message = f"{self.client_seed}:{self.nonce}"
        hmac_obj = hmac.new(
            self.server_seed.encode(),
            message.encode(),
            hashlib.sha512
        )
        hex_result = hmac_obj.hexdigest()
        
        # Step 2: Convert first 13 characters to integer
        # This gives us a number between 0 and 16^13 - 1
        random_int = int(hex_result[:13], 16)
        
        # Step 3: Normalize to float between 0 and 1
        # Maximum possible value from 13 hex chars is 16^13 - 1
        max_int = 16**13 - 1
        random_float = random_int / max_int
        
        # Step 4: Transform to crash point using exponential distribution
        # Formula: crash_point = max(1, (0.99 / (1 - random_float)))
        # The 0.99 factor creates the house edge (1% expected value reduction)
        raw_crash = (1 - self.house_edge) / (1 - random_float)
        
        # Step 5: Round to 2 decimal places (standard in crash games)
        crash_point = max(1.0, round(raw_crash, 2))
        
        self.crash_history.append(crash_point)
        return crash_point
    
    def simulate_rounds(self, num_rounds: int = 1000) -> List[float]:
        """Simulate multiple rounds and collect crash points."""
        print(f"üéÆ Simulating {num_rounds} rounds...")
        start_time = time.time()
        
        for i in range(num_rounds):
            self.generate_crash_point()
            if (i + 1) % 100 == 0:
                print(f"  Progress: {i + 1}/{num_rounds} rounds")
        
        elapsed = time.time() - start_time
        print(f"‚úÖ Completed {num_rounds} rounds in {elapsed:.2f} seconds\n")
        return self.crash_history
    
    def verify_round(self, round_number: int, server_seed: str, client_seed: str, nonce: int) -> float:
        """
        Verify a previous round's crash point.
        This demonstrates the provably fair verification process.
        """
        message = f"{client_seed}:{nonce}"
        hmac_obj = hmac.new(
            server_seed.encode(),
            message.encode(),
            hashlib.sha512
        )
        hex_result = hmac_obj.hexdigest()
        random_int = int(hex_result[:13], 16)
        max_int = 16**13 - 1
        random_float = random_int / max_int
        raw_crash = (1 - self.house_edge) / (1 - random_float)
        verified_point = max(1.0, round(raw_crash, 2))
        return verified_point
    
    def analyze_distribution(self):
        """Analyze and visualize the statistical distribution of crash points."""
        if not self.crash_history:
            print("No data to analyze. Run simulation first.")
            return
        
        crashes = np.array(self.crash_history)
        
        print("üìä Statistical Analysis")
        print(f"Total Rounds: {len(crashes)}")
        print(f"Mean Crash Point: {crashes.mean():.2f}x")
        print(f"Median Crash Point: {np.median(crashes):.2f}x")
        print(f"Std Deviation: {crashes.std():.2f}")
        print(f"Minimum: {crashes.min():.2f}x")
        print(f"Maximum: {crashes.max():.2f}x")
        print(f"Rounds at 1.00x: {sum(1 for c in crashes if c == 1.0)} ({sum(1 for c in crashes if c == 1.0)/len(crashes)*100:.1f}%)")
        print(f"Rounds > 10x: {sum(1 for c in crashes if c > 10)} ({sum(1 for c in crashes if c > 10)/len(crashes)*100:.2f}%)")
        print(f"Rounds > 50x: {sum(1 for c in crashes if c > 50)} ({sum(1 for c in crashes if c > 50)/len(crashes)*100:.4f}%)")
        
        # Calculate house edge verification
        expected_value = crashes.mean()
        fair_expected = 1 / (1 - self.house_edge)
        actual_edge = (1 - (1 / expected_value)) * 100 if expected_value > 0 else 0
        
        print(f"\nüí∞ House Edge Verification")
        print(f"Theoretical fair expected value: {fair_expected:.4f}x")
        print(f"Actual average crash point: {expected_value:.4f}x")
        print(f"Implied house edge: {actual_edge:.2f}%")
        
        # Visualization
        self.plot_distribution(crashes)
    
    def plot_distribution(self, crashes):
        """Create visualizations of the crash point distribution."""
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        fig.suptitle('Crash Game Statistics - Educational Visualization', fontsize=16)
        
        # Histogram of crash points (limited range for visibility)
        ax1 = axes[0, 0]
        filtered_crashes = [c for c in crashes if c <= 20]  # Limit to 20x for visibility
        ax1.hist(filtered_crashes, bins=50, alpha=0.7, color='blue', edgecolor='black')
        ax1.set_xlabel('Crash Multiplier (x)')
        ax1.set_ylabel('Frequency')
        ax1.set_title('Distribution of Crash Points (‚â§20x)')
        ax1.axvline(np.mean(filtered_crashes), color='red', linestyle='--', label=f'Mean: {np.mean(filtered_crashes):.2f}x')
        ax1.legend()
        
        # Log scale histogram
        ax2 = axes[0, 1]
        ax2.hist(crashes, bins=100, alpha=0.7, color='green', edgecolor='black', log=True)
        ax2.set_xlabel('Crash Multiplier (x)')
        ax2.set_ylabel('Frequency (log scale)')
        ax2.set_title('Distribution (Log Scale)')
        
        # Cumulative probability
        ax3 = axes[1, 0]
        sorted_crashes = np.sort(crashes)
        cumulative = np.arange(1, len(sorted_crashes) + 1) / len(sorted_crashes)
        ax3.plot(sorted_crashes, cumulative, 'b-', linewidth=2)
        ax3.set_xlabel('Crash Multiplier (x)')
        ax3.set_ylabel('Cumulative Probability')
        ax3.set_title('Probability of Crash ‚â• Multiplier')
        ax3.grid(True, alpha=0.3)
        
        # Recent rounds trend
        ax4 = axes[1, 1]
        recent = crashes[-100:] if len(crashes) > 100 else crashes
        ax4.plot(range(len(recent)), recent, 'r-', alpha=0.7, linewidth=1)
        ax4.set_xlabel('Round')
        ax4.set_ylabel('Crash Multiplier (x)')
        ax4.set_title('Recent 100 Rounds')
        ax4.axhline(y=np.mean(recent), color='blue', linestyle='--', label=f'Mean: {np.mean(recent):.2f}x')
        ax4.legend()
        
        plt.tight_layout()
        plt.show()

def educational_notes():
    """Print educational information about crash games and RNG."""
    print("\n" + "="*60)
    print("üìö EDUCATIONAL NOTES - WHY CRASH GAMES CANNOT BE PREDICTED")
    print("="*60)
    
    print("\n1Ô∏è‚É£ PROVABLY FAIR RNG:")
    print("   ‚Ä¢ Each round uses: HMAC_SHA512(server_seed, client_seed + nonce)")
    print("   ‚Ä¢ Server seed is hashed and revealed AFTER use")
    print("   ‚Ä¢ Players can verify every past round's fairness")
    print("   ‚Ä¢ Seeds are cryptographically secure (256+ bits of entropy)")
    
    print("\n2Ô∏è‚É£ PROBABILITY DISTRIBUTION:")
    print("   ‚Ä¢ Crash points follow an exponential-like distribution")
    print("   ‚Ä¢ P(crash ‚â• x) ‚âà (1 - house_edge) / x")
    print("   ‚Ä¢ Example: With 1% house edge")
    print("     - 2x occurs with ~49.5% probability")
    print("     - 10x occurs with ~9.9% probability")
    print("     - 100x occurs with ~0.99% probability")
    
    print("\n3Ô∏è‚É£ WHY PREDICTION IS IMPOSSIBLE:")
    print("   ‚Ä¢ No patterns exist - each round is independent")
    print("   ‚Ä¢ Previous results don't influence future results")
    print("   ‚Ä¢ The RNG is uniform - no 'hot' or 'cold' streaks")
    print("   ‚Ä¢ What looks like patterns is just randomness")
    print("   ‚Ä¢ The Gambler's Fallacy: 'It's due for a big multiplier' is FALSE")
    
    print("\n4Ô∏è‚É£ MATHEMATICAL EXPECTATION:")
    print("   ‚Ä¢ Expected value is less than 1.00")
    print("   ‚Ä¢ With 1% house edge: E[crash] ‚âà 1 / (1 - 0.01) = 1.01x")
    print("   ‚Ä¢ This means for every $1 bet, expected return is $0.99")
    print("   ‚Ä¢ House edge ensures casino profit over large samples")
    
    print("\n5Ô∏è‚É£ COMMON MISCONCEPTIONS:")
    print("   ‚ùå 'I can predict using machine learning'")
    print("      ‚Üí Impossible with true randomness - ML finds patterns that aren't there")
    print("   ‚ùå 'The game manipulates results'")
    print("      ‚Üí Provably fair verification prevents manipulation")
    print("   ‚ùå 'Betting systems can guarantee profit'")
    print("      ‚Üí No betting system can overcome negative expectation")
    print("   ‚ùå 'I'm due for a win'")
    print("      ‚Üí Each round is independent - no memory of previous results")
    
    print("\n‚ö†Ô∏è  DISCLAIMER: This is for EDUCATIONAL PURPOSES only.")
    print("   Real gambling involves risk of financial loss.")
    print("   There is no system or algorithm that can predict crash games.")
    print("="*60 + "\n")

def main():
    """Main demonstration function."""
    print("üöÄ CRASH GAME SIMULATOR - EDUCATIONAL DEMONSTRATION")
    print("="*60)
    print("This program simulates a provably fair crash gambling game")
    print("to demonstrate the mathematics and randomness involved.")
    print("No prediction or strategy is being offered or implied.\n")
    
    # Initialize simulator with random seeds
    simulator = CrashGameSimulator(house_edge=0.01)  # 1% house edge
    
    # Simulate 10,000 rounds for meaningful statistics
    simulator.simulate_rounds(10000)
    
    # Analyze the results
    simulator.analyze_distribution()
    
    # Verify a specific round to demonstrate provably fair
    print("\nüîç Provably Fair Verification Demo")
    print("-"*40)
    # Pick a random round to verify
    verify_round = random.randint(1, simulator.nonce)
    verified = simulator.verify_round(
        verify_round,
        simulator.server_seed,
        simulator.client_seed,
        verify_round
    )
    actual = simulator.crash_history[verify_round - 1]
    print(f"Round {verify_round}:")
    print(f"  Recorded crash point: {actual}x")
    print(f"  Verified crash point: {verified}x")
    print(f"  Verification: {'‚úÖ PASSED' if actual == verified else '‚ùå FAILED'}")
    
    # Reveal server seed (as would happen in real provably fair systems)
    print(f"\nüîê Server Seed (revealed): {simulator.server_seed}")
    print("In real systems, seeds are revealed after use for verification.")
    
    # Print educational notes
    educational_notes()

if __name__ == "__main__":
    main()
